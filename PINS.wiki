== How to Write a Performance Instrumentation module ==

This page will explain how to use the Performance INStrumentation (PINS) system to instrument the operation of PaRSEC. It uses the existing "print_steals" module (source code available in the src/mca/pins/print_steals directory) as an example of a bare-bones PINS module that does not require the use of the PaRSEC profiling system for the collection of its data, and does not use PAPI for hardware measurement purposes. For help with using PAPI and the profiling system in PaRSEC to perform low-impact hardware-provided event measurements, refer to the built-in "papi_exec" and "papi_select" modules once you understand the architecture of the PINS system.

PINS is implemented as an extension to the Modular Component Architecture, originally of OpenMPI. This provides very simple integration with the PaRSEC build process and PaRSEC runtime, at the cost of some extra 'markup' code in the *_component.c file for each module. You can use any MCA component or PINS module as a reference for how to write the code necessary for MCA to understand your PINS module.

A PINS module is generally comprised of two main pieces: the initialization and finalization code, and your custom instrumentation callback functions themselves. There are 3 pairs of initialization and finalization routines - each invoked by a specific part of the runtime - and your module may implement as many or as few of them as are needed. They are:
* {{{pins_init}}}
* {{{pins_fini}}}
* {{{pins_handle_init}}}
* {{{pins_handle_fini}}}
* {{{pins_thread_init}}}
* {{{pins_thread_fini}}}

Again, any of these 6 routines may be provided by your module, and they will be invoked automatically by the PaRSEC runtime if they exist. You **must** specify which of the init/fini routines are provided, using a dague_pins_module_t struct similar to the one in {{{print_steals}}}'s {{{pins_print_steals_module.c}}} file:

{{{
const dague_pins_module_t dague_pins_print_steals_module = {
    &dague_pins_print_steals_component,
    {
	    pins_init_print_steals, // name of function as prototyped
	    pins_fini_print_steals,
	    NULL, // HANDLE_INIT - not implemented, or not provided
	    NULL, // HANDLE_FINI - not implemented, or not provided
	    pins_thread_init_print_steals,
	    NULL  // THREAD_FINI - not implemented, or not provided
    }
};
}}}

It is customary to name the init/fini routines with the prefix "pins_<init/fini type>_<module name>" in order to maintain a level of consistency that will be of use to other module developers. This naming convention is fully demonstrated in the papi_exec, print_steals, papi_select, and papi_socket modules.

{{{pins_init}}} is invoked a single time, during {{{dague_init()}}}, before the PaRSEC profiling system is active, and before the entirety of the dague_context_t structure (particularlly including all virtual process and thread structures) is instantiated.  This is the right place to perform any custom initialization, such as global memory allocation, that does not depend on anything thread or handle-related. 

{{{pins_init}}} is also the usual place to make calls to {{{PINS_REGISTER()}}}, the macro which will register your custom callback code with whichever callbacks your module requires. It is customary, in order to provide callback-overloading, that you store the return value of PINS_REGISTER (a parsec_pins_callback function pointer) so that it can be called before your callback returns, as seen in {{{print_steals}}}:
{{{
static parsec_pins_callback * select_begin_prev; // courtesy calls to previously-registered cbs
static parsec_pins_callback * select_end_prev;
static int total_cores;

// This will be called by pins_init() if it has been properly placed in 
static void pins_init_print_steals(dague_context_t * master) {
	select_begin_prev = PINS_REGISTER(SELECT_BEGIN, start_print_steals_count);
	select_end_prev   = PINS_REGISTER(SELECT_END,   stop_print_steals_count);
	total_cores = master->nb_vp * master->virtual_processes[0]->nb_cores;
}

static void start_print_steals_count(dague_execution_unit_t * exec_unit, 
                                    dague_execution_context_t * exec_context, 
                                    void * data) {
   ....
	// keep the contract with the previous registrant
	if (select_begin_prev != NULL) {
		(*select_begin_prev)(exec_unit, exec_context, data);
	}
}

static void stop_print_steals_count(dague_execution_unit_t * exec_unit, 
                                   dague_execution_context_t * exec_context, 
                                   void * data) {
   ....
	// keep the contract with the previous registrant
	if (select_end_prev != NULL) {
		(*select_end_prev)(exec_unit, exec_context, data);
	}
}
}}}

